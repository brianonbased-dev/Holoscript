{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I use @on_break for destructible objects?"}, {"role": "assistant", "content": "Here's using `@on_break` for destructible objects:\n\n```holoscript\nscene DestructibleWorld {\n  // Basic breakable crate\n  prefab Crate {\n    object crate {\n      mesh: 'assets/props/crate.glb'\n      \n      @breakable {\n        health: 50\n        damage_types: ['physical', 'fire', 'explosive']\n      }\n      @grabbable\n      @throwable\n      \n      // Called when health reaches 0\n      @on_break(info) {\n        // info.attacker - what broke it\n        // info.damage_type - how it was broken\n        // info.position - break point\n        \n        // Play break sound\n        audio.play_spatial(\"wood_break\", self.position)\n        \n        // Spawn wood debris\n        @for (let i = 0; i < 6; i++) {\n          spawn \"WoodShard\" {\n            position: self.position\n            velocity: [\n              (Math.random() - 0.5) * 5,\n              Math.random() * 4,\n              (Math.random() - 0.5) * 5\n            ]\n          }\n        }\n        \n        // Chance to drop loot\n        if (Math.random() > 0.7) {\n          spawn \"HealthPickup\" { position: self.position }\n        }\n        \n        // Self destruct\n        self.destroy()\n      }\n    }\n  }\n  \n  // Breakable with staged damage\n  prefab Window {\n    object window {\n      mesh: 'assets/building/window_intact.glb'\n      \n      state {\n        damageLevel: 0  // 0=intact, 1=cracked, 2=shattered\n      }\n      \n      @breakable {\n        health: 30\n        stages: [20, 10, 0]  // Health thresholds for stages\n      }\n      \n      @on_damage(info) {\n        // Update visual based on remaining health\n        if (self.health <= 10 && state.damageLevel < 2) {\n          state.damageLevel = 2\n          self.mesh = 'assets/building/window_cracked_heavy.glb'\n          audio.play_spatial(\"glass_crack\", self.position)\n        } else if (self.health <= 20 && state.damageLevel < 1) {\n          state.damageLevel = 1\n          self.mesh = 'assets/building/window_cracked.glb'\n          audio.play_spatial(\"glass_crack_light\", self.position)\n        }\n      }\n      \n      @on_break(info) {\n        audio.play_spatial(\"glass_shatter\", self.position)\n        \n        // Glass shards\n        spawn \"GlassDebris\" {\n          position: self.position\n          count: 20\n          spread: 2\n        }\n        \n        // Replace with broken frame\n        spawn \"BrokenWindowFrame\" {\n          position: self.position\n          rotation: self.rotation\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n}\n```\n\n**@on_break info object:**\n- `info.attacker` - Entity that dealt final blow\n- `info.damage_type` - Type of damage\n- `info.position` - Impact position\n- `info.total_damage` - Total damage dealt"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create explosive barrels with chain reactions"}, {"role": "assistant", "content": "Here's explosive barrels with chain reactions:\n\n```holoscript\nscene ExplosiveBarrels {\n  prefab ExplosiveBarrel {\n    object barrel {\n      mesh: 'assets/props/barrel_explosive.glb'\n      \n      state {\n        isExploding: false\n        fuseTime: 0\n        chainReactionDelay: 0.1  // seconds\n      }\n      \n      @breakable {\n        health: 20\n        damage_types: ['physical', 'fire', 'explosive']\n        \n        // Extra vulnerable to fire/explosive\n        damage_multipliers: {\n          fire: 2.0,\n          explosive: 3.0\n        }\n      }\n      \n      @on_damage(info) {\n        // Fire damage starts a fuse\n        if (info.damage_type === 'fire' && !state.isExploding) {\n          self.startFuse()\n        }\n      }\n      \n      @on_break(info) {\n        self.explode(info.attacker)\n      }\n      \n      action startFuse() {\n        state.isExploding = true\n        \n        // Warning animation\n        animation Shake {\n          property: 'rotation'\n          keyframes: [\n            [0, 0, 0],\n            [0, 0, 3],\n            [0, 0, -3],\n            [0, 0, 2],\n            [0, 0, -2],\n            [0, 0, 0]\n          ]\n          duration: 200\n          loop: 5\n        }\n        \n        // Warning sound\n        audio.play_spatial(\"fuse_burning\", self.position)\n        \n        // Delayed explosion\n        setTimeout(() => {\n          if (!self.destroyed) {\n            self.explode(null)\n          }\n        }, 2000)\n      }\n      \n      action explode(attacker) {\n        if (self.destroyed) return\n        \n        let explosionRadius = 5\n        let explosionDamage = 100\n        \n        // Visual explosion\n        spawn \"Explosion\" {\n          position: self.position\n          scale: 2\n        }\n        \n        // Sound\n        audio.play_spatial(\"explosion_large\", self.position, { volume: 1.5 })\n        \n        // Screen shake for nearby player\n        if (player.distanceTo(self.position) < 10) {\n          camera.shake(0.5, 500)\n        }\n        \n        // Damage nearby objects\n        let nearbyObjects = physics.overlapSphere(self.position, explosionRadius)\n        \n        for (let obj of nearbyObjects) {\n          if (obj === self) continue\n          \n          let distance = obj.position.distanceTo(self.position)\n          let falloff = 1 - (distance / explosionRadius)\n          let damage = explosionDamage * falloff\n          \n          // Apply damage\n          if (obj.hasComponent('breakable')) {\n            obj.takeDamage(damage, 'explosive', self)\n          }\n          \n          // Apply force\n          if (obj.hasComponent('physics')) {\n            let direction = obj.position.subtract(self.position).normalize()\n            obj.applyImpulse(direction.multiply(falloff * 20))\n          }\n        }\n        \n        // Spawn debris\n        @for (let i = 0; i < 8; i++) {\n          spawn \"MetalDebris\" {\n            position: self.position\n            velocity: [\n              (Math.random() - 0.5) * 10,\n              Math.random() * 8,\n              (Math.random() - 0.5) * 10\n            ]\n          }\n        }\n        \n        // Fire hazard left behind\n        spawn \"FireHazard\" {\n          position: self.position\n          duration: 5  // seconds\n          radius: 2\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Fire hazard that spreads to other barrels\n  prefab FireHazard {\n    object fire {\n      particles FireParticles {\n        preset: 'fire'\n        rate: 50\n      }\n      \n      light {\n        type: 'point'\n        color: '#ff6600'\n        intensity: 2\n        range: 4\n      }\n      \n      state {\n        duration: 5\n        radius: 2\n      }\n      \n      @on_mount {\n        // Damage things in fire\n        every(500) {\n          let inFire = physics.overlapSphere(self.position, state.radius)\n          \n          for (let obj of inFire) {\n            if (obj.hasComponent('breakable')) {\n              obj.takeDamage(10, 'fire', self)\n            }\n          }\n        }\n        \n        // Self-destruct after duration\n        setTimeout(() => self.destroy(), state.duration * 1000)\n      }\n    }\n  }\n}\n```\n\nChain reaction features:\n- Damage multipliers for different types\n- Fuse mechanic for fire damage\n- Radial damage with falloff\n- Force impulse on physics objects\n- Fire hazard for sustained damage"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Breakable doors and walls"}, {"role": "assistant", "content": "Here's destructible architecture:\n\n```holoscript\nscene DestructibleBuilding {\n  // Breakable wooden door\n  prefab WoodenDoor {\n    object door {\n      mesh: 'assets/building/door_wood.glb'\n      \n      state {\n        isLocked: false\n        damageStage: 0\n      }\n      \n      @breakable {\n        health: 80\n        armor: 5  // Reduces incoming damage\n        immune_to: ['fire']  // Wood doesn't burn instantly\n      }\n      @interactive\n      \n      // Normal interaction - open/close\n      @on_interact {\n        if (!state.isLocked) {\n          self.toggleOpen()\n        } else {\n          audio.play(\"door_locked\")\n          ui.showHint(\"Door is locked\")\n        }\n      }\n      \n      @on_damage(info) {\n        // Visual damage stages\n        if (self.health <= 40 && state.damageStage < 1) {\n          state.damageStage = 1\n          self.mesh = 'assets/building/door_wood_damaged.glb'\n          audio.play_spatial(\"wood_crack\", self.position)\n        }\n        if (self.health <= 20 && state.damageStage < 2) {\n          state.damageStage = 2\n          self.mesh = 'assets/building/door_wood_broken.glb'\n        }\n      }\n      \n      @on_break(info) {\n        audio.play_spatial(\"door_break\", self.position)\n        \n        // Door splinters\n        spawn \"WoodDebris\" {\n          position: self.position\n          count: 12\n          size: 'medium'\n        }\n        \n        // Leave door frame\n        spawn \"DoorFrame\" {\n          position: self.position\n          rotation: self.rotation\n        }\n        \n        // Achievement check\n        if (info.attacker === player) {\n          achievements.progress(\"door_breacher\", 1)\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Reinforced door - harder to break\n  prefab ReinforcedDoor {\n    object door {\n      mesh: 'assets/building/door_metal.glb'\n      \n      @breakable {\n        health: 300\n        armor: 20\n        damage_types: ['explosive']  // Only explosive can break\n        resist: {\n          physical: 0.8,  // 80% physical resistance\n          fire: 1.0       // Immune to fire\n        }\n      }\n      \n      @on_damage(info) {\n        if (info.damage_type !== 'explosive') {\n          audio.play_spatial(\"metal_clang\", self.position)\n          spawn \"Sparks\" { position: info.position }\n        }\n      }\n      \n      @on_break(info) {\n        audio.play_spatial(\"metal_break\", self.position)\n        camera.shake(0.3, 300)\n        \n        spawn \"MetalDebris\" {\n          position: self.position\n          count: 8\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Destructible wall section\n  prefab DestructibleWall {\n    object wall {\n      mesh: 'assets/building/wall_section.glb'\n      size: [3, 3, 0.3]\n      \n      state {\n        holePositions: []  // Track bullet holes\n      }\n      \n      @breakable {\n        health: 200\n        partial_destruction: true  // Can create holes\n      }\n      \n      @on_damage(info) {\n        // Create bullet holes for small damage\n        if (info.damage < 20) {\n          state.holePositions.push(info.position)\n          \n          spawn \"BulletHole\" {\n            position: info.position\n            rotation: info.normal\n            parent: self\n          }\n        }\n        // Create crack for medium damage\n        else if (info.damage < 50) {\n          spawn \"WallCrack\" {\n            position: info.position\n            size: info.damage / 10\n            parent: self\n          }\n        }\n      }\n      \n      @on_break(info) {\n        audio.play_spatial(\"wall_collapse\", self.position)\n        \n        // Major debris\n        spawn \"RubbleDebris\" {\n          position: self.position\n          size: 'large'\n          count: 20\n        }\n        \n        // Dust cloud\n        spawn \"DustCloud\" {\n          position: self.position\n          radius: 3\n          duration: 3\n        }\n        \n        // Screen shake\n        camera.shake(0.5, 500)\n        \n        // Open navigation\n        navigation.updateNavMesh(self.bounds)\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Wall with structural support\n  prefab LoadBearingWall {\n    object wall {\n      @breakable {\n        health: 400\n        is_structural: true\n      }\n      \n      @on_break(info) {\n        // Check if this causes collapse\n        let connectedStructure = building.getConnectedStructure(self)\n        \n        if (!building.hasAlternativeSupport(connectedStructure)) {\n          // Trigger collapse of unsupported sections\n          building.collapseSection(connectedStructure)\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n}\n```\n\nArchitectural destruction:\n- Damage stages with visual updates\n- Partial destruction (bullet holes)\n- Door frame remains\n- Rubble and dust effects\n- Structural collapse chains\n- Navigation mesh updates"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Enemy death with @on_break"}, {"role": "assistant", "content": "Here's enemy death handling:\n\n```holoscript\nscene Combat {\n  prefab Enemy {\n    object enemy {\n      mesh: 'assets/enemies/goblin.glb'\n      \n      state {\n        name: 'Goblin'\n        level: 1\n        xpReward: 50\n        lootTable: 'goblin_common'\n        deathAnimation: 'death_fall'\n        isElite: false\n      }\n      \n      @breakable {\n        health: 100\n        damage_types: ['physical', 'fire', 'ice', 'lightning']\n        \n        // Elemental weaknesses\n        damage_multipliers: {\n          fire: 1.5,\n          ice: 0.8\n        }\n      }\n      \n      trait AI {\n        behavior: 'hostile'\n        detection_range: 10\n        attack_range: 2\n      }\n      \n      @on_damage(info) {\n        // Flinch animation\n        animation Flinch {\n          clip: 'hit_react'\n          duration: 300\n        }\n        \n        // Damage number popup\n        spawn \"DamageNumber\" {\n          position: [self.position[0], self.position[1] + 2, self.position[2]]\n          state: {\n            value: info.damage,\n            isCrit: info.isCritical,\n            type: info.damage_type\n          }\n        }\n        \n        // Blood effect\n        spawn \"BloodSplatter\" {\n          position: info.position\n          rotation: info.normal\n        }\n        \n        // Aggro if not already\n        if (!self.ai.hasTarget) {\n          self.ai.setTarget(info.attacker)\n        }\n      }\n      \n      @on_break(info) {\n        // === DEATH SEQUENCE ===\n        \n        // 1. Stop AI and physics\n        self.ai.disable()\n        self.physics = 'kinematic'\n        \n        // 2. Play death animation\n        animation Death {\n          clip: state.deathAnimation\n          duration: 1200\n          onComplete: () => self.startDecompose()\n        }\n        \n        // 3. Death sound\n        audio.play_spatial(\"${state.name.toLowerCase()}_death\", self.position)\n        \n        // 4. Award XP to player\n        if (info.attacker === player || info.attacker?.owner === player) {\n          let xp = state.xpReward * (state.isElite ? 3 : 1)\n          player.addXP(xp)\n          \n          spawn \"XPPopup\" {\n            position: self.position\n            state: { value: xp }\n          }\n        }\n        \n        // 5. Drop loot\n        let loot = lootSystem.roll(state.lootTable, state.level)\n        \n        for (let item of loot) {\n          spawn \"LootDrop\" {\n            position: [\n              self.position[0] + (Math.random() - 0.5),\n              self.position[1] + 0.5,\n              self.position[2] + (Math.random() - 0.5)\n            ]\n            state: { item: item }\n          }\n        }\n        \n        // 6. Quest/objective progress\n        quests.progress('kill', state.name, 1)\n        \n        // 7. Stats tracking\n        stats.increment('enemies_killed')\n        stats.increment(`${state.name.toLowerCase()}_killed`)\n        \n        // 8. Elite death effects\n        if (state.isElite) {\n          // Extra fanfare\n          spawn \"EliteDeathEffect\" { position: self.position }\n          audio.play(\"elite_defeated\")\n          ui.showBanner(\"Elite ${state.name} Defeated!\")\n        }\n        \n        // 9. Check if last enemy\n        let remainingEnemies = scene.getObjectsWithTag('enemy').length - 1\n        if (remainingEnemies === 0) {\n          events.emit('all_enemies_defeated')\n        }\n      }\n      \n      action startDecompose() {\n        // Fade out body\n        animation FadeOut {\n          property: 'opacity'\n          keyframes: [1, 0]\n          duration: 2000\n          onComplete: () => self.destroy()\n        }\n        \n        // Sink into ground\n        animation Sink {\n          property: 'position.y'\n          keyframes: [self.position[1], self.position[1] - 0.5]\n          duration: 2000\n        }\n      }\n    }\n  }\n  \n  // Boss with special death\n  prefab Boss {\n    object boss {\n      @breakable {\n        health: 5000\n        armor: 50\n      }\n      \n      @on_break(info) {\n        // Dramatic death\n        game.slowMotion(0.3, 2000)\n        camera.focusOn(self, { duration: 3000 })\n        \n        // Phase out attacks\n        self.cancelAllAbilities()\n        \n        // Death cutscene\n        animation BossDeath {\n          clip: 'boss_death_dramatic'\n          duration: 5000\n        }\n        \n        // Massive loot explosion\n        for (let i = 0; i < 20; i++) {\n          setTimeout(() => {\n            spawn \"LootGeyser\" {\n              position: self.position\n              delay: i * 100\n            }\n          }, i * 100)\n        }\n        \n        // Victory music\n        audio.crossfade('boss_victory', 2000)\n        \n        // Unlock next area\n        events.emit('boss_defeated', state.bossId)\n        \n        // Destroy after animation\n        setTimeout(() => self.destroy(), 6000)\n      }\n    }\n  }\n}\n```\n\nEnemy death features:\n- Death animation sequence\n- XP rewards\n- Loot table drops\n- Quest progression\n- Stats tracking\n- Body decomposition\n- Boss special effects"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Breakable environment puzzles"}, {"role": "assistant", "content": "Here's puzzles using breakable objects:\n\n```holoscript\nscene BreakablePuzzles {\n  // Crack the floor to reveal secret\n  prefab WeakFloor {\n    object floor {\n      mesh: 'assets/dungeon/floor_cracked.glb'\n      \n      state {\n        jumpCount: 0\n        requiredJumps: 3\n      }\n      \n      @breakable {\n        health: 100\n        damage_types: ['impact']  // Only physical impact\n      }\n      \n      @on_collision(other) {\n        if (other === player && player.isJumping && player.velocity.y < -2) {\n          state.jumpCount++\n          \n          // Visual crack progression\n          let crackLevel = Math.min(state.jumpCount, 3)\n          self.mesh = `assets/dungeon/floor_crack_${crackLevel}.glb`\n          \n          audio.play_spatial(\"floor_crack\", self.position)\n          camera.shake(0.2, 200)\n          \n          if (state.jumpCount >= state.requiredJumps) {\n            self.health = 0  // Trigger break\n          }\n        }\n      }\n      \n      @on_break {\n        audio.play_spatial(\"floor_collapse\", self.position)\n        \n        spawn \"FallingDebris\" {\n          position: self.position\n          count: 15\n        }\n        \n        // Reveal hidden room below\n        spawn \"SecretRoom\" {\n          position: [self.position[0], self.position[1] - 5, self.position[2]]\n        }\n        \n        // Player falls through\n        player.applyForce([0, -10, 0])\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Chain reaction puzzle\n  state {\n    pillarsBroken: 0\n    requiredPillars: 4\n  }\n  \n  prefab StructuralPillar {\n    object pillar {\n      mesh: 'assets/dungeon/pillar.glb'\n      \n      state {\n        index: 0\n      }\n      \n      @breakable {\n        health: 150\n      }\n      \n      @on_break {\n        scene.state.pillarsBroken++\n        \n        audio.play_spatial(\"pillar_fall\", self.position)\n        \n        // Pillar topples\n        spawn \"FallingPillar\" {\n          position: self.position\n          rotation: [0, 0, 0]\n          animation: 'topple'\n        }\n        \n        // Check if all pillars broken\n        if (scene.state.pillarsBroken >= scene.state.requiredPillars) {\n          // Ceiling collapses\n          scene.collapseCeiling()\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  action collapseCeiling() {\n    audio.play(\"rumble_large\")\n    camera.shake(1.0, 3000)\n    \n    // Ceiling mesh breaks apart\n    let ceiling = scene.getObject(\"BossCeiling\")\n    ceiling.triggerBreak()\n    \n    // Sunlight streams in\n    spawn \"SunBeam\" {\n      position: [0, 20, 0]\n      intensity: 5\n    }\n    \n    // Boss weakness revealed\n    events.emit('boss_weakness_exposed')\n  }\n  \n  // Ice wall puzzle - use fire\n  prefab IceWall {\n    object wall {\n      mesh: 'assets/elements/ice_wall.glb'\n      \n      trait Material {\n        preset: 'ice'\n        opacity: 0.8\n      }\n      \n      @breakable {\n        health: 200\n        damage_types: ['fire', 'physical']\n        damage_multipliers: {\n          fire: 5.0,     // Very weak to fire\n          physical: 0.2   // Resistant to physical\n        }\n      }\n      \n      @on_damage(info) {\n        if (info.damage_type === 'fire') {\n          // Melting effect\n          spawn \"Steam\" {\n            position: info.position\n          }\n          \n          // Shrink slightly\n          self.scale *= 0.95\n        }\n      }\n      \n      @on_break {\n        audio.play_spatial(\"ice_shatter\", self.position)\n        \n        spawn \"IceShards\" {\n          position: self.position\n          count: 30\n        }\n        \n        spawn \"WaterPuddle\" {\n          position: [self.position[0], 0, self.position[2]]\n        }\n        \n        // Path is now clear\n        self.destroy()\n      }\n    }\n  }\n  \n  // Crystal that powers barrier\n  prefab PowerCrystal {\n    object crystal {\n      mesh: 'assets/magic/crystal.glb'\n      \n      state {\n        connectedBarrier: null\n      }\n      \n      trait Material {\n        emissive: '#ff00ff'\n        emissive_intensity: 2\n      }\n      \n      light {\n        type: 'point'\n        color: '#ff00ff'\n        intensity: 3\n        range: 8\n      }\n      \n      @breakable {\n        health: 50\n      }\n      \n      @on_break {\n        audio.play_spatial(\"crystal_shatter\", self.position)\n        \n        // Crystal explosion\n        spawn \"MagicBurst\" {\n          position: self.position\n          color: '#ff00ff'\n        }\n        \n        // Disable connected barrier\n        if (state.connectedBarrier) {\n          state.connectedBarrier.deactivate()\n          \n          spawn \"BarrierDissipate\" {\n            position: state.connectedBarrier.position\n          }\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n  \n  // Sequence puzzle - break in order\n  prefab SequenceOrb {\n    object orb {\n      state {\n        correctOrder: 0  // 0, 1, 2, 3...\n        isActive: false\n      }\n      \n      trait Material {\n        emissive: '#00ffff'\n        emissive_intensity: state.isActive ? 3 : 0.5\n      }\n      \n      @breakable {\n        health: 10\n      }\n      \n      @on_break {\n        if (puzzle.currentStep === state.correctOrder) {\n          // Correct!\n          puzzle.currentStep++\n          audio.play(\"puzzle_correct\")\n          \n          spawn \"SuccessParticles\" { position: self.position }\n          \n          if (puzzle.currentStep >= puzzle.totalSteps) {\n            puzzle.complete()\n          }\n        } else {\n          // Wrong order - reset puzzle\n          audio.play(\"puzzle_wrong\")\n          puzzle.reset()\n          \n          // Respawn all orbs\n          puzzle.respawnOrbs()\n        }\n        \n        self.destroy()\n      }\n    }\n  }\n}\n```\n\nPuzzle patterns:\n- Progressive damage (jump count)\n- Chain reaction requirements\n- Elemental weaknesses\n- Power source destruction\n- Sequence/order puzzles\n- Environmental reveals"}]}
