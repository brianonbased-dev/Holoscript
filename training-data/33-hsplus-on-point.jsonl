{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I use @on_point for laser pointer interactions?"}, {"role": "assistant", "content": "Here's using `@on_point` for laser/ray interactions:\n\n```holoscript\nscene LaserInteractions {\n  // Basic pointable button\n  prefab LaserButton {\n    object button {\n      mesh: 'assets/ui/3d_button.glb'\n      \n      @pointable {\n        highlight_on_point: true\n        highlight_color: '#00ff00'\n      }\n      \n      // Called when laser first hits\n      @on_point_enter {\n        audio.play(\"button_hover\")\n        \n        animation Highlight {\n          property: 'scale'\n          keyframes: [1, 1.1]\n          duration: 150\n        }\n        \n        // Show tooltip\n        ui.showTooltip(\"Press trigger to activate\")\n      }\n      \n      // Called every frame while pointed\n      @on_point(info) {\n        // info.point - world position of ray hit\n        // info.distance - distance from controller\n        // info.controller - which controller is pointing\n        \n        // Update pointer visual to hit point\n        info.controller.pointer.endpoint = info.point\n      }\n      \n      // Called when laser leaves\n      @on_point_exit {\n        animation Unhighlight {\n          property: 'scale'\n          keyframes: [1.1, 1]\n          duration: 150\n        }\n        \n        ui.hideTooltip()\n      }\n      \n      // Called when trigger pressed while pointing\n      @on_point_select {\n        audio.play(\"button_click\")\n        haptic_pulse(0.5)\n        \n        animation Press {\n          property: 'position.z'\n          keyframes: [0, -0.02, 0]\n          duration: 200\n        }\n        \n        self.activate()\n      }\n    }\n  }\n  \n  // Distance-based interaction\n  prefab InfoPanel {\n    object panel {\n      mesh: 'assets/ui/info_panel.glb'\n      \n      state {\n        detailLevel: 0  // 0=none, 1=basic, 2=detailed\n      }\n      \n      @pointable\n      \n      @on_point(info) {\n        // More detail when pointing closer\n        if (info.distance < 1) {\n          if (state.detailLevel !== 2) {\n            state.detailLevel = 2\n            self.showDetailedInfo()\n          }\n        } else if (info.distance < 3) {\n          if (state.detailLevel !== 1) {\n            state.detailLevel = 1\n            self.showBasicInfo()\n          }\n        }\n      }\n      \n      @on_point_exit {\n        state.detailLevel = 0\n        self.hideInfo()\n      }\n    }\n  }\n}\n```\n\n**@on_point info object:**\n- `info.point` - World position where ray hits\n- `info.distance` - Distance from controller to hit\n- `info.normal` - Surface normal at hit point\n- `info.controller` - Controller doing the pointing\n- `info.uv` - UV coordinates at hit (for textures)"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a laser-based menu system"}, {"role": "assistant", "content": "Here's a complete laser menu system:\n\n```holoscript\nscene LaserMenu {\n  // Floating menu panel\n  object MainMenu {\n    position: [0, 1.5, -2]\n    \n    // Background panel\n    object Background {\n      geometry: 'plane'\n      size: [1.5, 1]\n      \n      trait Material {\n        color: '#1a1a2e'\n        opacity: 0.9\n      }\n    }\n    \n    // Menu title\n    text3d Title {\n      content: \"Game Menu\"\n      position: [0, 0.35, 0.01]\n      size: 0.08\n      color: '#ffffff'\n    }\n    \n    // Menu buttons\n    object[] MenuButtons {\n      state {\n        options: [\n          { label: 'New Game', action: 'startGame' },\n          { label: 'Continue', action: 'loadGame' },\n          { label: 'Settings', action: 'openSettings' },\n          { label: 'Quit', action: 'quitGame' }\n        ]\n      }\n      \n      @for (let i = 0; i < state.options.length; i++) {\n        let opt = state.options[i]\n        let yPos = 0.15 - i * 0.15\n        \n        object Button_${i} {\n          position: [0, yPos, 0.02]\n          \n          object ButtonBg {\n            geometry: 'plane'\n            size: [1.2, 0.12]\n            \n            trait Material {\n              color: '#2d2d44'\n            }\n          }\n          \n          text3d Label {\n            content: opt.label\n            position: [0, 0, 0.01]\n            size: 0.05\n            color: '#ffffff'\n            align: 'center'\n          }\n          \n          @pointable {\n            priority: 1\n          }\n          \n          @on_point_enter {\n            audio.play(\"menu_hover\")\n            \n            ButtonBg.material.color = '#4a4a6a'\n            Label.color = '#00ffff'\n            \n            animation Grow {\n              property: 'scale'\n              keyframes: [1, 1.05]\n              duration: 100\n            }\n          }\n          \n          @on_point_exit {\n            ButtonBg.material.color = '#2d2d44'\n            Label.color = '#ffffff'\n            \n            animation Shrink {\n              property: 'scale'\n              keyframes: [1.05, 1]\n              duration: 100\n            }\n          }\n          \n          @on_point_select {\n            audio.play(\"menu_select\")\n            haptic_pulse(0.3)\n            \n            animation Press {\n              property: 'position.z'\n              keyframes: [0.02, 0, 0.02]\n              duration: 150\n            }\n            \n            menu.executeAction(opt.action)\n          }\n        }\n      }\n    }\n  }\n  \n  // Slider control\n  prefab VolumeSlider {\n    object slider {\n      state {\n        value: 0.7  // 0 to 1\n        isDragging: false\n        label: 'Volume'\n      }\n      \n      object Track {\n        geometry: 'box'\n        size: [1, 0.02, 0.02]\n        \n        trait Material {\n          color: '#333333'\n        }\n        \n        @pointable\n        \n        @on_point_select(info) {\n          // Click to set value\n          let localX = self.worldToLocal(info.point).x\n          state.value = Math.max(0, Math.min(1, (localX + 0.5)))\n          self.updateSlider()\n        }\n      }\n      \n      object Fill {\n        geometry: 'box'\n        size: [state.value, 0.02, 0.025]\n        position: [(state.value - 1) / 2, 0, 0]\n        \n        trait Material {\n          color: '#00ff88'\n        }\n      }\n      \n      object Handle {\n        geometry: 'sphere'\n        radius: 0.04\n        position: [state.value - 0.5, 0, 0]\n        \n        trait Material {\n          color: '#ffffff'\n        }\n        \n        @pointable\n        @grabbable\n        \n        @on_grab_start {\n          state.isDragging = true\n        }\n        \n        @on_grab_move(info) {\n          // Constrain to track\n          let localX = Track.worldToLocal(info.position).x\n          state.value = Math.max(0, Math.min(1, localX + 0.5))\n          self.updateSlider()\n        }\n        \n        @on_grab_end {\n          state.isDragging = false\n          settings.setVolume(state.value)\n        }\n      }\n      \n      text3d ValueLabel {\n        content: \"${Math.round(state.value * 100)}%\"\n        position: [0.7, 0, 0]\n        size: 0.04\n      }\n      \n      action updateSlider() {\n        Handle.position = [state.value - 0.5, 0, 0]\n        Fill.size = [state.value, 0.02, 0.025]\n        Fill.position = [(state.value - 1) / 2, 0, 0]\n        ValueLabel.content = \"${Math.round(state.value * 100)}%\"\n      }\n    }\n  }\n  \n  // Toggle switch\n  prefab ToggleSwitch {\n    object toggle {\n      state {\n        isOn: false\n        label: 'Option'\n      }\n      \n      object Track {\n        geometry: 'box'\n        size: [0.15, 0.06, 0.03]\n        \n        trait Material {\n          color: state.isOn ? '#00ff88' : '#444444'\n        }\n      }\n      \n      object Knob {\n        geometry: 'sphere'\n        radius: 0.035\n        position: [state.isOn ? 0.04 : -0.04, 0, 0.02]\n        \n        trait Material {\n          color: '#ffffff'\n        }\n      }\n      \n      @pointable\n      \n      @on_point_enter {\n        Knob.material.emissive = '#ffffff'\n        Knob.material.emissive_intensity = 0.3\n      }\n      \n      @on_point_exit {\n        Knob.material.emissive_intensity = 0\n      }\n      \n      @on_point_select {\n        state.isOn = !state.isOn\n        \n        audio.play(state.isOn ? \"switch_on\" : \"switch_off\")\n        haptic_pulse(0.2)\n        \n        animation SlideKnob {\n          target: Knob\n          property: 'position.x'\n          keyframes: [Knob.position.x, state.isOn ? 0.04 : -0.04]\n          duration: 150\n          easing: 'ease-out'\n        }\n        \n        Track.material.color = state.isOn ? '#00ff88' : '#444444'\n        \n        events.emit('toggle_changed', { option: state.label, value: state.isOn })\n      }\n    }\n  }\n}\n```\n\nMenu system features:\n- Hover highlights\n- Click/select actions\n- Slider with drag\n- Toggle switches\n- Visual feedback\n- Haptic feedback"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Laser targeting for shooting"}, {"role": "assistant", "content": "Here's laser targeting for weapons:\n\n```holoscript\nscene WeaponTargeting {\n  // Weapon with laser sight\n  prefab LaserGun {\n    object gun {\n      mesh: 'assets/weapons/laser_pistol.glb'\n      \n      state {\n        currentTarget: null\n        isAiming: false\n        ammo: 30\n        damage: 25\n      }\n      \n      @grabbable {\n        grab_points: [\n          { position: [0, -0.05, 0], rotation: [0, 0, 0] }\n        ]\n      }\n      \n      // Laser sight beam\n      object LaserSight {\n        type: 'line'\n        start: [0, 0, 0.1]  // Barrel position\n        end: [0, 0, 50]      // Max range\n        \n        trait Material {\n          color: '#ff0000'\n          opacity: 0.6\n          lineWidth: 2\n        }\n        \n        visible: false  // Only when aiming\n      }\n      \n      // Laser dot at target\n      object LaserDot {\n        geometry: 'plane'\n        size: [0.05, 0.05]\n        \n        trait Material {\n          color: '#ff0000'\n          emissive: '#ff0000'\n          emissive_intensity: 2\n          billboard: true\n        }\n        \n        visible: false\n      }\n      \n      @on_grab {\n        state.isAiming = true\n        LaserSight.visible = true\n      }\n      \n      @on_release {\n        state.isAiming = false\n        LaserSight.visible = false\n        LaserDot.visible = false\n        self.clearTarget()\n      }\n      \n      @on_update {\n        if (!state.isAiming) return\n        \n        // Cast ray from barrel\n        let ray = physics.raycast(\n          self.getWorldPosition(LaserSight.start),\n          self.forward,\n          50  // Max distance\n        )\n        \n        if (ray.hit) {\n          // Update laser endpoint\n          LaserSight.end = self.worldToLocal(ray.point)\n          \n          // Position laser dot\n          LaserDot.visible = true\n          LaserDot.position = ray.point\n          LaserDot.rotation = ray.normal\n          \n          // Check if target is enemy\n          if (ray.object.hasTag('enemy')) {\n            self.setTarget(ray.object, ray.point)\n          } else {\n            self.clearTarget()\n          }\n        } else {\n          LaserSight.end = [0, 0, 50]\n          LaserDot.visible = false\n          self.clearTarget()\n        }\n      }\n      \n      action setTarget(target, hitPoint) {\n        if (state.currentTarget !== target) {\n          // Clear old target\n          if (state.currentTarget) {\n            state.currentTarget.setHighlight(false)\n          }\n          \n          state.currentTarget = target\n          target.setHighlight(true)\n          \n          // Change laser color for valid target\n          LaserSight.material.color = '#00ff00'\n          LaserDot.material.color = '#00ff00'\n          LaserDot.material.emissive = '#00ff00'\n        }\n      }\n      \n      action clearTarget() {\n        if (state.currentTarget) {\n          state.currentTarget.setHighlight(false)\n          state.currentTarget = null\n          \n          LaserSight.material.color = '#ff0000'\n          LaserDot.material.color = '#ff0000'\n          LaserDot.material.emissive = '#ff0000'\n        }\n      }\n      \n      // Trigger to fire\n      @on_trigger(value) {\n        if (value > 0.8 && state.ammo > 0) {\n          self.fire()\n        }\n      }\n      \n      action fire() {\n        state.ammo--\n        \n        audio.play_spatial(\"laser_fire\", self.position)\n        haptic_pulse(0.4)\n        \n        // Muzzle flash\n        spawn \"MuzzleFlash\" {\n          position: self.getWorldPosition([0, 0, 0.15])\n          duration: 0.1\n        }\n        \n        // If we have a target, damage it\n        if (state.currentTarget) {\n          state.currentTarget.takeDamage(state.damage, 'energy', self)\n          \n          spawn \"LaserHitEffect\" {\n            position: LaserDot.position\n          }\n        }\n      }\n    }\n  }\n  \n  // Enemy with targeting highlight\n  prefab Enemy {\n    object enemy {\n      state {\n        isHighlighted: false\n      }\n      \n      // Targeting indicator\n      object TargetIndicator {\n        mesh: 'assets/ui/target_reticle.glb'\n        scale: 1.5\n        \n        visible: false\n        \n        animation Spin {\n          property: 'rotation.z'\n          keyframes: [0, 360]\n          duration: 2000\n          loop: infinite\n        }\n      }\n      \n      @pointable\n      \n      // Highlight when pointed at\n      @on_point_enter {\n        self.setHighlight(true)\n      }\n      \n      @on_point_exit {\n        // Only unhighlight if not being targeted by weapon\n        if (!state.isWeaponTarget) {\n          self.setHighlight(false)\n        }\n      }\n      \n      action setHighlight(enabled) {\n        state.isHighlighted = enabled\n        TargetIndicator.visible = enabled\n        \n        if (enabled) {\n          self.material.emissive = '#ff0000'\n          self.material.emissive_intensity = 0.3\n        } else {\n          self.material.emissive_intensity = 0\n        }\n      }\n    }\n  }\n}\n```\n\nWeapon targeting features:\n- Real-time raycast aiming\n- Laser sight visualization\n- Target validation (enemy check)\n- Visual target indicator\n- Color change for valid targets\n- Damage on trigger fire"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Point to inspect objects and get info"}, {"role": "assistant", "content": "Here's object inspection with pointing:\n\n```holoscript\nscene ObjectInspection {\n  // Inspectable item\n  prefab InspectableItem {\n    object item {\n      state {\n        name: 'Mysterious Artifact'\n        description: 'An ancient relic of unknown origin.'\n        details: [\n          'Material: Unknown crystal',\n          'Age: ~3000 years',\n          'Origin: Lost Temple',\n          'Value: Priceless'\n        ]\n        isInspecting: false\n        inspectTime: 0\n      }\n      \n      @pointable {\n        cursor: 'inspect'\n      }\n      \n      // Quick hover - show name\n      @on_point_enter {\n        ui.showLabel(state.name, self.position + [0, 0.5, 0])\n        \n        // Subtle highlight\n        self.material.emissive = '#4488ff'\n        self.material.emissive_intensity = 0.2\n      }\n      \n      @on_point_exit {\n        ui.hideLabel()\n        ui.hideInspectPanel()\n        \n        self.material.emissive_intensity = 0\n        state.isInspecting = false\n        state.inspectTime = 0\n      }\n      \n      // Extended point - reveal details progressively\n      @on_point(info) {\n        state.inspectTime += deltaTime\n        \n        // After 0.5s - show description\n        if (state.inspectTime > 0.5 && !state.isInspecting) {\n          state.isInspecting = true\n          \n          ui.showInspectPanel({\n            title: state.name,\n            description: state.description,\n            position: info.point + [0.5, 0, 0]\n          })\n          \n          audio.play(\"inspect_start\")\n        }\n        \n        // After 1.5s - show detailed info\n        if (state.inspectTime > 1.5) {\n          let detailIndex = Math.min(\n            Math.floor((state.inspectTime - 1.5) / 0.5),\n            state.details.length - 1\n          )\n          \n          ui.updateInspectPanel({\n            details: state.details.slice(0, detailIndex + 1)\n          })\n        }\n        \n        // Visual: rotate toward player slightly\n        let lookDir = player.position.subtract(self.position).normalize()\n        self.rotation.y = Math.atan2(lookDir.x, lookDir.z) * 180 / Math.PI\n      }\n      \n      // Trigger while pointing - add to journal\n      @on_point_select {\n        if (state.isInspecting) {\n          journal.addEntry({\n            type: 'artifact',\n            name: state.name,\n            description: state.description,\n            details: state.details,\n            image: self.captureSnapshot()\n          })\n          \n          audio.play(\"journal_add\")\n          ui.showNotification(\"Added to journal\")\n        }\n      }\n    }\n  }\n  \n  // Environmental scanning\n  prefab ScanNode {\n    object node {\n      state {\n        scanData: {\n          type: 'Energy Signature',\n          readings: [\n            { label: 'Frequency', value: '432 Hz' },\n            { label: 'Amplitude', value: '7.3 mV' },\n            { label: 'Pattern', value: 'Oscillating' }\n          ],\n          hazardLevel: 'Low'\n        }\n        scanProgress: 0\n        isScanned: false\n      }\n      \n      // Pulsing indicator when unscanned\n      object ScanIndicator {\n        geometry: 'sphere'\n        radius: 0.1\n        \n        visible: !state.isScanned\n        \n        trait Material {\n          color: '#00ffff'\n          emissive: '#00ffff'\n          opacity: 0.7\n        }\n        \n        animation Pulse {\n          property: 'scale'\n          keyframes: [1, 1.3, 1]\n          duration: 1500\n          loop: infinite\n        }\n      }\n      \n      @pointable\n      \n      @on_point(info) {\n        if (state.isScanned) return\n        \n        state.scanProgress += deltaTime\n        \n        // Update scan progress UI\n        ui.showScanProgress({\n          progress: state.scanProgress / 2,  // 2 seconds to scan\n          label: 'Scanning...'\n        })\n        \n        // Scan beam effect\n        spawn \"ScanBeam\" {\n          start: info.controller.position,\n          end: info.point,\n          persist: false\n        }\n        \n        // Complete scan\n        if (state.scanProgress >= 2) {\n          state.isScanned = true\n          ScanIndicator.visible = false\n          \n          audio.play(\"scan_complete\")\n          haptic_pulse(0.5, 300)\n          \n          ui.hideScanProgress()\n          ui.showScanResult(state.scanData)\n          \n          // Add to map\n          map.addPOI(self.position, state.scanData.type)\n        }\n      }\n      \n      @on_point_exit {\n        // Reset if not complete\n        if (!state.isScanned && state.scanProgress > 0) {\n          state.scanProgress = Math.max(0, state.scanProgress - 0.5)\n          ui.hideScanProgress()\n        }\n      }\n    }\n  }\n  \n  // NPC with conversation preview\n  prefab NPC {\n    object npc {\n      state {\n        name: 'Elder Sage',\n        mood: 'friendly',\n        hasQuest: true,\n        dialoguePreview: 'Traveler! I have urgent news...'\n      }\n      \n      @pointable\n      \n      // Name and mood indicator\n      @on_point_enter {\n        // Show name plate\n        spawn \"NamePlate\" {\n          text: state.name\n          position: self.position + [0, 2.2, 0]\n          color: state.hasQuest ? '#ffff00' : '#ffffff'\n          parent: self\n        }\n        \n        // NPC acknowledges being looked at\n        self.lookAt(player)\n        \n        animation Wave {\n          clip: 'acknowledge'\n          duration: 500\n        }\n      }\n      \n      // Show dialogue preview after dwelling\n      @on_point(info) {\n        if (info.dwellTime > 1.0) {\n          ui.showDialoguePreview({\n            speaker: state.name,\n            text: state.dialoguePreview,\n            hasQuest: state.hasQuest\n          })\n        }\n      }\n      \n      @on_point_exit {\n        ui.hideDialoguePreview()\n        NamePlate.destroy()\n      }\n      \n      @on_point_select {\n        dialogue.start(self)\n      }\n    }\n  }\n}\n```\n\nInspection features:\n- Progressive detail reveal\n- Dwell time tracking\n- Journal integration\n- Environmental scanning\n- NPC awareness\n- Visual feedback during inspection"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Laser pointer for drawing in VR"}, {"role": "assistant", "content": "Here's a VR drawing system with laser:\n\n```holoscript\nscene VRDrawing {\n  state {\n    isDrawing: false\n    currentStroke: null\n    allStrokes: []\n    brushColor: '#ff0000'\n    brushSize: 0.02\n    brushType: 'solid'  // solid, glow, ribbon\n  }\n  \n  // Drawing controller\n  object DrawingTool {\n    attachment: 'right_hand'\n    \n    // Pointer beam\n    object Pointer {\n      type: 'line'\n      start: [0, 0, 0]\n      end: [0, 0, 5]\n      \n      trait Material {\n        color: state.brushColor\n        opacity: 0.5\n      }\n    }\n    \n    // Cursor at draw point\n    object Cursor {\n      geometry: 'sphere'\n      radius: state.brushSize\n      \n      trait Material {\n        color: state.brushColor\n        emissive: state.brushColor\n        emissive_intensity: 0.5\n      }\n    }\n    \n    @on_update {\n      // Raycast to find draw surface/point\n      let ray = physics.raycast(self.position, self.forward, 10)\n      \n      if (ray.hit) {\n        Cursor.position = ray.point\n        Cursor.visible = true\n        Pointer.end = self.worldToLocal(ray.point)\n      } else {\n        // Draw in air at fixed distance\n        Cursor.position = self.position + self.forward * 2\n        Cursor.visible = true\n        Pointer.end = [0, 0, 2]\n      }\n    }\n    \n    // Continuous point for drawing\n    @on_point(info) {\n      if (state.isDrawing && state.currentStroke) {\n        // Add point to current stroke\n        let newPoint = Cursor.position.clone()\n        \n        // Only add if moved enough (prevents too many points)\n        let lastPoint = state.currentStroke.points.slice(-1)[0]\n        if (!lastPoint || newPoint.distanceTo(lastPoint) > state.brushSize * 0.5) {\n          state.currentStroke.addPoint(newPoint)\n        }\n      }\n    }\n    \n    // Trigger to draw\n    @on_trigger_down {\n      state.isDrawing = true\n      \n      // Start new stroke\n      state.currentStroke = spawn \"Stroke\" {\n        color: state.brushColor\n        size: state.brushSize\n        type: state.brushType\n      }\n      \n      state.allStrokes.push(state.currentStroke)\n      audio.play(\"draw_start\")\n    }\n    \n    @on_trigger_up {\n      state.isDrawing = false\n      \n      if (state.currentStroke) {\n        state.currentStroke.finalize()\n        state.currentStroke = null\n        audio.play(\"draw_end\")\n      }\n    }\n    \n    // Grip to undo\n    @on_grip {\n      if (state.allStrokes.length > 0) {\n        let lastStroke = state.allStrokes.pop()\n        lastStroke.destroy()\n        audio.play(\"undo\")\n        haptic_pulse(0.2)\n      }\n    }\n  }\n  \n  // Stroke object\n  prefab Stroke {\n    object stroke {\n      state {\n        points: []\n        color: '#ff0000'\n        size: 0.02\n        type: 'solid'\n      }\n      \n      // Dynamic tube mesh\n      mesh: null\n      \n      action addPoint(point) {\n        state.points.push(point)\n        self.rebuildMesh()\n      }\n      \n      action rebuildMesh() {\n        if (state.points.length < 2) return\n        \n        // Generate tube along points\n        self.mesh = geometry.createTube({\n          path: state.points,\n          radius: state.size,\n          segments: 8,\n          closed: false\n        })\n        \n        // Apply material based on type\n        if (state.type === 'solid') {\n          self.material = {\n            color: state.color,\n            metalness: 0.3,\n            roughness: 0.7\n          }\n        } else if (state.type === 'glow') {\n          self.material = {\n            color: state.color,\n            emissive: state.color,\n            emissive_intensity: 2,\n            transparent: true,\n            opacity: 0.8\n          }\n        } else if (state.type === 'ribbon') {\n          // Flat ribbon instead of tube\n          self.mesh = geometry.createRibbon({\n            path: state.points,\n            width: state.size * 4,\n            segments: state.points.length - 1\n          })\n          self.material = {\n            color: state.color,\n            side: 'double'\n          }\n        }\n      }\n      \n      action finalize() {\n        // Optimize mesh for performance\n        self.mesh = geometry.simplify(self.mesh, 0.5)\n        \n        // Enable physics if needed\n        self.collider = 'mesh'\n      }\n    }\n  }\n  \n  // Color palette\n  object ColorPalette {\n    position: [-0.3, 1.2, -0.5]\n    attachment: 'left_hand'\n    \n    state {\n      colors: ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#00ffff', '#0088ff', '#8800ff', '#ff00ff', '#ffffff', '#000000']\n    }\n    \n    @for (let i = 0; i < state.colors.length; i++) {\n      let angle = (i / state.colors.length) * Math.PI * 2\n      let radius = 0.08\n      \n      object ColorSwatch_${i} {\n        geometry: 'sphere'\n        radius: 0.015\n        position: [\n          Math.cos(angle) * radius,\n          Math.sin(angle) * radius,\n          0\n        ]\n        \n        trait Material {\n          color: state.colors[i]\n          emissive: state.colors[i]\n          emissive_intensity: 0.3\n        }\n        \n        @pointable\n        \n        @on_point_enter {\n          self.scale = 1.3\n        }\n        \n        @on_point_exit {\n          self.scale = 1.0\n        }\n        \n        @on_point_select {\n          scene.state.brushColor = state.colors[i]\n          audio.play(\"color_select\")\n          haptic_pulse(0.2)\n          \n          // Update pointer color\n          DrawingTool.Pointer.material.color = state.colors[i]\n          DrawingTool.Cursor.material.color = state.colors[i]\n          DrawingTool.Cursor.material.emissive = state.colors[i]\n        }\n      }\n    }\n    \n    // Size slider\n    object SizeControl {\n      position: [0, -0.1, 0]\n      \n      @for (let s = 1; s <= 5; s++) {\n        object Size_${s} {\n          geometry: 'sphere'\n          radius: s * 0.006\n          position: [(s - 3) * 0.04, 0, 0]\n          \n          trait Material {\n            color: '#888888'\n          }\n          \n          @pointable\n          \n          @on_point_select {\n            scene.state.brushSize = s * 0.01\n            DrawingTool.Cursor.radius = scene.state.brushSize\n            audio.play(\"size_select\")\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nDrawing features:\n- Raycast for surface/air drawing\n- Trigger to draw, grip to undo\n- Dynamic tube mesh generation\n- Multiple brush types\n- Color palette on hand\n- Size control\n- Stroke optimization"}]}
