{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I use @for loops in HoloScript?"}, {"role": "assistant", "content": "HoloScript uses `@for` for declarative object generation:\n\n```holoscript\nscene ForLoopExamples {\n  // Basic grid generation\n  @for (let x = 0; x < 5; x++) {\n    @for (let z = 0; z < 5; z++) {\n      object Tile_${x}_${z} {\n        geometry: 'box'\n        size: [0.9, 0.1, 0.9]\n        position: [x, 0, z]\n        \n        trait Material {\n          color: (x + z) % 2 === 0 ? '#ffffff' : '#333333'\n        }\n      }\n    }\n  }\n  \n  // Linear array of objects\n  @for (let i = 0; i < 10; i++) {\n    object Pillar_${i} {\n      geometry: 'cylinder'\n      size: [0.5, 3, 0.5]\n      position: [i * 2, 1.5, -5]\n      \n      trait Material {\n        color: `hsl(${i * 36}, 70%, 50%)`\n      }\n    }\n  }\n  \n  // Circular arrangement\n  state {\n    treeCount: 12\n    radius: 10\n  }\n  \n  @for (let i = 0; i < state.treeCount; i++) {\n    let angle = (i / state.treeCount) * Math.PI * 2\n    \n    object Tree_${i} {\n      mesh: 'assets/nature/tree.glb'\n      position: [\n        Math.cos(angle) * state.radius,\n        0,\n        Math.sin(angle) * state.radius\n      ]\n      rotation: [0, angle * 180 / Math.PI, 0]  // Face center\n    }\n  }\n}\n```\n\n**@for patterns:**\n- Grid: Nested `@for` with x, z\n- Line: Single `@for` with offset\n- Circle: `@for` with angle calculation\n- Named objects: `Object_${i}` or `Object_${x}_${z}`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Generate a procedural dungeon floor with @for"}, {"role": "assistant", "content": "Here's procedural dungeon generation:\n\n```holoscript\nscene ProceduralDungeon {\n  state {\n    width: 20\n    depth: 20\n    tileSize: 2\n    seed: 12345\n  }\n  \n  // Seeded random function\n  action seededRandom(x, z) {\n    let n = Math.sin(x * 12.9898 + z * 78.233 + state.seed) * 43758.5453\n    return n - Math.floor(n)\n  }\n  \n  // Generate floor tiles with variation\n  @for (let x = 0; x < state.width; x++) {\n    @for (let z = 0; z < state.depth; z++) {\n      let rand = seededRandom(x, z)\n      let isWall = x === 0 || z === 0 || x === state.width - 1 || z === state.depth - 1\n      let isObstacle = !isWall && rand > 0.85\n      \n      // Floor tile\n      object Floor_${x}_${z} {\n        geometry: 'box'\n        size: [state.tileSize - 0.05, 0.2, state.tileSize - 0.05]\n        position: [x * state.tileSize, 0, z * state.tileSize]\n        \n        trait Material {\n          preset: 'stone'\n          color: `hsl(30, 10%, ${20 + rand * 15}%)`  // Slight variation\n        }\n      }\n      \n      // Wall blocks on edges\n      @if (isWall) {\n        object Wall_${x}_${z} {\n          geometry: 'box'\n          size: [state.tileSize, 3, state.tileSize]\n          position: [x * state.tileSize, 1.5, z * state.tileSize]\n          \n          trait Material {\n            preset: 'stone_brick'\n          }\n        }\n      }\n      \n      // Random obstacles\n      @if (isObstacle) {\n        object Obstacle_${x}_${z} {\n          mesh: rand > 0.92 ? 'assets/dungeon/barrel.glb' : 'assets/dungeon/crate.glb'\n          position: [x * state.tileSize, 0.5, z * state.tileSize]\n          rotation: [0, rand * 360, 0]\n          \n          @breakable {\n            health: 30\n            loot_table: 'dungeon_crate'\n          }\n        }\n      }\n      \n      // Occasional torches on walls\n      @if (isWall && rand > 0.7) {\n        object Torch_${x}_${z} {\n          mesh: 'assets/dungeon/torch.glb'\n          position: [\n            x * state.tileSize + (x === 0 ? 0.9 : x === state.width - 1 ? -0.9 : 0),\n            2,\n            z * state.tileSize + (z === 0 ? 0.9 : z === state.depth - 1 ? -0.9 : 0)\n          ]\n          \n          light {\n            type: 'point'\n            color: '#ff8844'\n            intensity: 1.5\n            range: 6\n          }\n          \n          particles Fire {\n            preset: 'torch_flame'\n          }\n        }\n      }\n    }\n  }\n  \n  // Place enemies based on rooms\n  state {\n    enemyPositions: [\n      [5, 5], [10, 8], [15, 12], [8, 15]\n    ]\n  }\n  \n  @for (let i = 0; i < state.enemyPositions.length; i++) {\n    let pos = state.enemyPositions[i]\n    \n    object Enemy_${i} using \"Skeleton\" {\n      position: [pos[0] * state.tileSize, 0, pos[1] * state.tileSize]\n      state: {\n        patrolRadius: 3\n      }\n    }\n  }\n}\n```\n\nProcedural features:\n- Seeded randomness for reproducibility\n- Edge detection for walls\n- Random obstacle placement\n- Conditional torch spawning\n- Enemy placement from data"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Iterate over arrays with @for"}, {"role": "assistant", "content": "Here's iterating over data arrays:\n\n```holoscript\nscene DataDrivenScene {\n  // Spawn from position array\n  state {\n    spawnPoints: [\n      { position: [0, 0, 5], type: 'enemy' },\n      { position: [5, 0, 3], type: 'chest' },\n      { position: [-3, 0, 8], type: 'npc' },\n      { position: [2, 0, 10], type: 'enemy' }\n    ]\n  }\n  \n  @for (let i = 0; i < state.spawnPoints.length; i++) {\n    let spawn = state.spawnPoints[i]\n    \n    @if (spawn.type === 'enemy') {\n      object Enemy_${i} using \"Goblin\" {\n        position: spawn.position\n      }\n    }\n    \n    @if (spawn.type === 'chest') {\n      object Chest_${i} using \"TreasureChest\" {\n        position: spawn.position\n      }\n    }\n    \n    @if (spawn.type === 'npc') {\n      object NPC_${i} using \"Villager\" {\n        position: spawn.position\n      }\n    }\n  }\n  \n  // Inventory display\n  state {\n    inventory: [\n      { name: 'Health Potion', icon: 'potion_red', count: 5 },\n      { name: 'Mana Potion', icon: 'potion_blue', count: 3 },\n      { name: 'Gold Key', icon: 'key_gold', count: 1 },\n      { name: 'Map', icon: 'scroll', count: 1 }\n    ]\n  }\n  \n  ui_panel InventoryUI {\n    position: [50, 50]\n    \n    @for (let i = 0; i < state.inventory.length; i++) {\n      let item = state.inventory[i]\n      \n      ui_slot Slot_${i} {\n        position: [(i % 4) * 60, Math.floor(i / 4) * 60]\n        size: [50, 50]\n        \n        icon: \"assets/icons/${item.icon}.png\"\n        \n        @if (item.count > 1) {\n          text Count {\n            content: \"${item.count}\"\n            position: [35, 35]\n            size: 12\n          }\n        }\n        \n        @on_hover {\n          tooltip.show(item.name)\n        }\n      }\n    }\n  }\n  \n  // Building from blueprint\n  state {\n    blueprint: [\n      { model: 'wall', x: 0, z: 0, rot: 0 },\n      { model: 'wall', x: 1, z: 0, rot: 0 },\n      { model: 'door', x: 2, z: 0, rot: 0 },\n      { model: 'wall', x: 3, z: 0, rot: 0 },\n      { model: 'window', x: 0, z: 1, rot: 90 },\n      { model: 'roof', x: 1.5, z: 0.5, rot: 0, y: 3 }\n    ]\n  }\n  \n  spatial_group Building {\n    @for (let i = 0; i < state.blueprint.length; i++) {\n      let piece = state.blueprint[i]\n      \n      object Part_${i} {\n        mesh: \"assets/building/${piece.model}.glb\"\n        position: [piece.x * 2, piece.y || 0, piece.z * 2]\n        rotation: [0, piece.rot, 0]\n      }\n    }\n  }\n  \n  // Waypoint path\n  state {\n    waypoints: [\n      [0, 0, 0],\n      [5, 0, 2],\n      [8, 0, 8],\n      [3, 0, 12],\n      [0, 0, 15]\n    ]\n  }\n  \n  @for (let i = 0; i < state.waypoints.length; i++) {\n    object Marker_${i} {\n      mesh: 'assets/ui/waypoint_marker.glb'\n      position: state.waypoints[i]\n      \n      text3d Label {\n        content: \"${i + 1}\"\n        position: [0, 1, 0]\n      }\n    }\n    \n    // Line between waypoints\n    @if (i < state.waypoints.length - 1) {\n      object Path_${i} {\n        type: 'line'\n        start: state.waypoints[i]\n        end: state.waypoints[i + 1]\n        color: '#ffff00'\n        width: 0.1\n      }\n    }\n  }\n}\n```\n\nArray iteration patterns:\n- Index-based: `@for (let i = 0; i < arr.length; i++)`\n- Object destructuring via `let item = arr[i]`\n- Conditional spawning with `@if`\n- Grid layout: `(i % cols), Math.floor(i / cols)`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a 3D bar chart with @for loops"}, {"role": "assistant", "content": "Here's a 3D data visualization:\n\n```holoscript\nscene DataVisualization {\n  state {\n    chartData: [\n      { label: 'Jan', value: 120, color: '#4285f4' },\n      { label: 'Feb', value: 95, color: '#ea4335' },\n      { label: 'Mar', value: 150, color: '#fbbc05' },\n      { label: 'Apr', value: 80, color: '#34a853' },\n      { label: 'May', value: 200, color: '#ff6d01' },\n      { label: 'Jun', value: 175, color: '#46bdc6' }\n    ]\n    maxValue: 200\n    barWidth: 0.8\n    barSpacing: 1.2\n    heightScale: 0.02  // Value to height multiplier\n  }\n  \n  // Chart base\n  object ChartBase {\n    geometry: 'box'\n    size: [state.chartData.length * state.barSpacing + 1, 0.1, 2]\n    position: [state.chartData.length * state.barSpacing / 2 - 0.5, -0.05, 0]\n    \n    trait Material {\n      color: '#333333'\n    }\n  }\n  \n  // Generate bars\n  @for (let i = 0; i < state.chartData.length; i++) {\n    let data = state.chartData[i]\n    let barHeight = data.value * state.heightScale\n    \n    // Bar\n    object Bar_${i} {\n      geometry: 'box'\n      size: [state.barWidth, barHeight, state.barWidth]\n      position: [i * state.barSpacing, barHeight / 2, 0]\n      \n      trait Material {\n        color: data.color\n        metalness: 0.3\n        roughness: 0.7\n      }\n      \n      @hoverable {\n        glow: true\n        glow_color: '#ffffff'\n      }\n      @pointable\n      \n      @on_hover_enter {\n        // Show tooltip\n        spawn \"Tooltip\" {\n          position: [i * state.barSpacing, barHeight + 0.5, 0]\n          state: {\n            text: \"${data.label}: ${data.value}\"\n          }\n        }\n        \n        // Highlight animation\n        animation Highlight {\n          property: 'scale'\n          keyframes: [1, 1.1]\n          duration: 200\n        }\n      }\n      \n      @on_hover_exit {\n        Tooltip.destroy()\n        animation Unhighlight {\n          property: 'scale'\n          keyframes: [1.1, 1]\n          duration: 200\n        }\n      }\n    }\n    \n    // X-axis label\n    text3d Label_${i} {\n      content: data.label\n      position: [i * state.barSpacing, -0.3, 0.5]\n      rotation: [0, 0, 0]\n      size: 0.2\n      color: '#ffffff'\n    }\n    \n    // Value label on top\n    text3d Value_${i} {\n      content: \"${data.value}\"\n      position: [i * state.barSpacing, barHeight + 0.2, 0]\n      size: 0.15\n      color: '#ffffff'\n      billboard: true\n    }\n  }\n  \n  // Y-axis with grid lines\n  @for (let y = 0; y <= 4; y++) {\n    let value = (y / 4) * state.maxValue\n    let yPos = value * state.heightScale\n    \n    // Grid line\n    object GridLine_${y} {\n      geometry: 'box'\n      size: [state.chartData.length * state.barSpacing, 0.01, 0.01]\n      position: [state.chartData.length * state.barSpacing / 2 - 0.5, yPos, -state.barWidth / 2 - 0.1]\n      \n      trait Material {\n        color: '#666666'\n        opacity: 0.5\n      }\n    }\n    \n    // Y-axis label\n    text3d YLabel_${y} {\n      content: \"${value}\"\n      position: [-0.8, yPos, 0]\n      size: 0.15\n      color: '#aaaaaa'\n    }\n  }\n  \n  // Animate bars on load\n  @on_mount {\n    @for (let i = 0; i < state.chartData.length; i++) {\n      let bar = scene.getObject(\"Bar_${i}\")\n      \n      bar.animation GrowIn {\n        property: 'scale.y'\n        keyframes: [0, 1]\n        duration: 800\n        delay: i * 100  // Staggered\n        easing: 'ease-out'\n      }\n    }\n  }\n}\n```\n\nVisualization features:\n- Dynamic bar heights\n- Color coding from data\n- Hover tooltips\n- Y-axis grid lines\n- Staggered entrance animation"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a staircase with @for"}, {"role": "assistant", "content": "Here's generating stairs with @for:\n\n```holoscript\nscene Staircases {\n  // Simple straight staircase\n  state {\n    stepCount: 12\n    stepWidth: 2\n    stepHeight: 0.2\n    stepDepth: 0.3\n  }\n  \n  spatial_group StraightStairs {\n    position: [0, 0, 0]\n    \n    @for (let i = 0; i < state.stepCount; i++) {\n      object Step_${i} {\n        geometry: 'box'\n        size: [state.stepWidth, state.stepHeight, state.stepDepth]\n        position: [0, i * state.stepHeight + state.stepHeight / 2, i * state.stepDepth]\n        \n        trait Material {\n          preset: 'wood_oak'\n        }\n        \n        collider: 'box'\n      }\n    }\n    \n    // Handrail\n    @for (let side = -1; side <= 1; side += 2) {\n      object Handrail_${side === -1 ? 'L' : 'R'} {\n        geometry: 'cylinder'\n        size: [0.05, state.stepCount * state.stepHeight * 1.4, 0.05]\n        position: [\n          side * (state.stepWidth / 2 + 0.1),\n          state.stepCount * state.stepHeight / 2 + 0.8,\n          state.stepCount * state.stepDepth / 2\n        ]\n        rotation: [${Math.atan2(state.stepCount * state.stepHeight, state.stepCount * state.stepDepth) * 180 / Math.PI}, 0, 0]\n        \n        trait Material {\n          preset: 'metal_brass'\n        }\n      }\n      \n      // Balusters\n      @for (let i = 0; i < state.stepCount; i++) {\n        object Baluster_${side === -1 ? 'L' : 'R'}_${i} {\n          geometry: 'cylinder'\n          size: [0.03, 0.8, 0.03]\n          position: [\n            side * (state.stepWidth / 2 + 0.1),\n            i * state.stepHeight + 0.4,\n            i * state.stepDepth\n          ]\n          \n          trait Material {\n            preset: 'metal_brass'\n          }\n        }\n      }\n    }\n  }\n  \n  // Spiral staircase\n  state {\n    spiralSteps: 16\n    spiralRadius: 2\n    spiralHeight: 4\n    rotationsCount: 1.5\n  }\n  \n  spatial_group SpiralStairs {\n    position: [8, 0, 0]\n    \n    // Central pole\n    object CenterPole {\n      geometry: 'cylinder'\n      size: [0.15, state.spiralHeight + 1, 0.15]\n      position: [0, state.spiralHeight / 2, 0]\n      \n      trait Material {\n        preset: 'metal_iron'\n      }\n    }\n    \n    @for (let i = 0; i < state.spiralSteps; i++) {\n      let angle = (i / state.spiralSteps) * state.rotationsCount * Math.PI * 2\n      let y = (i / state.spiralSteps) * state.spiralHeight\n      \n      // Wedge-shaped step\n      object SpiralStep_${i} {\n        mesh: 'assets/architecture/spiral_step.glb'\n        position: [0, y, 0]\n        rotation: [0, angle * 180 / Math.PI, 0]\n        \n        trait Material {\n          preset: 'marble_white'\n        }\n        \n        collider: 'mesh'\n      }\n      \n      // Outer baluster\n      object SpiralBaluster_${i} {\n        geometry: 'cylinder'\n        size: [0.04, 0.9, 0.04]\n        position: [\n          Math.cos(angle) * state.spiralRadius,\n          y + 0.45,\n          Math.sin(angle) * state.spiralRadius\n        ]\n        \n        trait Material {\n          preset: 'metal_iron'\n        }\n      }\n    }\n    \n    // Spiral handrail (approximated with segments)\n    @for (let i = 0; i < state.spiralSteps - 1; i++) {\n      let angle1 = (i / state.spiralSteps) * state.rotationsCount * Math.PI * 2\n      let angle2 = ((i + 1) / state.spiralSteps) * state.rotationsCount * Math.PI * 2\n      let y1 = (i / state.spiralSteps) * state.spiralHeight + 0.9\n      let y2 = ((i + 1) / state.spiralSteps) * state.spiralHeight + 0.9\n      \n      object RailSegment_${i} {\n        type: 'tube'\n        path: [\n          [Math.cos(angle1) * state.spiralRadius, y1, Math.sin(angle1) * state.spiralRadius],\n          [Math.cos(angle2) * state.spiralRadius, y2, Math.sin(angle2) * state.spiralRadius]\n        ]\n        radius: 0.04\n        \n        trait Material {\n          preset: 'metal_iron'\n        }\n      }\n    }\n  }\n  \n  // Platform at top\n  object TopPlatform {\n    geometry: 'box'\n    size: [3, 0.2, 3]\n    position: [8, state.spiralHeight, 0]\n    \n    trait Material {\n      preset: 'marble_white'\n    }\n  }\n}\n```\n\nStaircase patterns:\n- Incremental height: `i * stepHeight`\n- Incremental depth: `i * stepDepth`\n- Spiral angle: `(i / total) * rotations * 2Ï€`\n- Spiral position: `[cos(angle) * r, y, sin(angle) * r]`\n- Mirrored sides: `@for side = -1 to 1 step 2`"}]}
