/**
 * @holoscript/unity-adapter
 *
 * Unity/C# adapter for HoloScript - Generate Unity-ready C# scripts and prefabs.
 *
 * This package compiles HoloScript (.holo/.hsplus) to:
 * - C# MonoBehaviour scripts
 * - Unity prefab definitions (.prefab)
 * - Unity scene files (.unity)
 * - Material definitions (.mat)
 *
 * @example Basic export to Unity project
 * ```typescript
 * import { HoloScriptPlusParser } from '@holoscript/core';
 * import { exportToUnity } from '@holoscript/unity-adapter';
 *
 * const parser = new HoloScriptPlusParser();
 * const { ast } = parser.parse(`
 *   orb#ball @grabbable @throwable {
 *     color: "#ff0000"
 *     position: [0, 1, 0]
 *   }
 * `);
 *
 * const result = await exportToUnity(ast, {
 *   outputDir: './UnityProject/Assets/HoloScript',
 *   projectName: 'MyWorld',
 *   xrFramework: 'xr-interaction-toolkit', // or 'oculus', 'steamvr'
 * });
 *
 * console.log(`Generated ${result.stats.scriptCount} C# scripts`);
 * console.log(`Created ${result.stats.prefabCount} prefabs`);
 * ```
 *
 * @example Generate C# code string (no file write)
 * ```typescript
 * import { generateCSharp } from '@holoscript/unity-adapter';
 *
 * const csharp = generateCSharp(ast, { namespace: 'MyGame.HoloScript' });
 * console.log(csharp);
 * ```
 *
 * @version 1.0.0
 * @license MIT
 */

import type { ASTNode } from '@holoscript/core';

// ============================================================================
// Types
// ============================================================================

export interface UnityExportConfig {
  /** Output directory (Unity Assets folder) */
  outputDir: string;
  /** Project/namespace name */
  projectName: string;
  /** XR framework to target */
  xrFramework?: 'xr-interaction-toolkit' | 'oculus' | 'steamvr' | 'none';
  /** Generate .meta files for Unity */
  generateMeta?: boolean;
  /** C# namespace for generated scripts */
  namespace?: string;
  /** Unity version target */
  unityVersion?: string;
}

export interface UnityExportResult {
  success: boolean;
  files: GeneratedFile[];
  stats: ExportStats;
  warnings: ExportWarning[];
  errors: ExportError[];
}

export interface GeneratedFile {
  path: string;
  content: string;
  type: 'script' | 'prefab' | 'scene' | 'material' | 'meta';
}

export interface ExportStats {
  scriptCount: number;
  prefabCount: number;
  materialCount: number;
  sceneCount: number;
  totalFiles: number;
}

export interface ExportWarning {
  code: string;
  message: string;
  node?: string;
}

export interface ExportError {
  code: string;
  message: string;
  node?: string;
}

// ============================================================================
// Trait to Unity Component Mapping
// ============================================================================

const TRAIT_TO_COMPONENT: Record<string, string[]> = {
  grabbable: ['XRGrabInteractable', 'Rigidbody'],
  throwable: ['XRGrabInteractable', 'Rigidbody', 'ThrowableObject'],
  pointable: ['XRSimpleInteractable'],
  hoverable: ['XRSimpleInteractable', 'HoverHighlight'],
  climbable: ['ClimbInteractable'],
  physics: ['Rigidbody', 'Collider'],
  breakable: ['BreakableObject', 'Rigidbody'],
  portal: ['PortalTeleporter'],
  npc: ['NPCController', 'NavMeshAgent'],
  audio: ['AudioSource'],
  particle: ['ParticleSystem'],
};

// ============================================================================
// C# Code Generation
// ============================================================================

/**
 * Generate C# MonoBehaviour code from HoloScript AST
 */
export function generateCSharp(
  ast: ASTNode,
  options: { namespace?: string } = {}
): string {
  const ns = options.namespace || 'HoloScript.Generated';
  const className = toPascalCase(ast.id || 'HoloObject');

  const traits = ast.traits || [];
  const components = getRequiredComponents(traits);
  const properties = generateProperties(ast);
  const methods = generateMethods(ast, traits);

  return `// Auto-generated by @holoscript/unity-adapter
// Do not edit manually - regenerate from .hsplus source

using UnityEngine;
using UnityEngine.XR.Interaction.Toolkit;

namespace ${ns}
{
    /// <summary>
    /// Generated from HoloScript: ${ast.id || 'unknown'}
    /// Traits: ${traits.join(', ') || 'none'}
    /// </summary>
    [RequireComponent(typeof(Collider))]
${components.map((c) => `    [RequireComponent(typeof(${c}))]`).join('\n')}
    public class ${className} : MonoBehaviour
    {
${properties}

${methods}
    }
}
`;
}

function getRequiredComponents(traits: string[]): string[] {
  const components = new Set<string>();
  for (const trait of traits) {
    const comps = TRAIT_TO_COMPONENT[trait] || [];
    comps.forEach((c) => components.add(c));
  }
  return Array.from(components);
}

function generateProperties(ast: ASTNode): string {
  const props: string[] = [];

  if (ast.position) {
    props.push(
      `        [SerializeField] private Vector3 _initialPosition = new Vector3(${ast.position.join(', ')});`
    );
  }
  if (ast.color) {
    const hex = ast.color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;
    props.push(
      `        [SerializeField] private Color _color = new Color(${r.toFixed(3)}f, ${g.toFixed(3)}f, ${b.toFixed(3)}f);`
    );
  }
  if (ast.scale) {
    const scale = Array.isArray(ast.scale) ? ast.scale : [ast.scale, ast.scale, ast.scale];
    props.push(
      `        [SerializeField] private Vector3 _scale = new Vector3(${scale.join('f, ')}f);`
    );
  }

  return props.join('\n');
}

function generateMethods(ast: ASTNode, traits: string[]): string {
  const methods: string[] = [];

  // Awake
  methods.push(`        private void Awake()
        {
            transform.localPosition = _initialPosition;
            transform.localScale = _scale;
            
            var renderer = GetComponent<Renderer>();
            if (renderer != null && _color != default)
            {
                renderer.material.color = _color;
            }
        }`);

  // Trait-specific methods
  if (traits.includes('grabbable')) {
    methods.push(`
        public void OnSelectEntered(SelectEnterEventArgs args)
        {
            // Grabbable: Object picked up
            Debug.Log($"{gameObject.name} grabbed by {args.interactorObject}");
        }

        public void OnSelectExited(SelectExitEventArgs args)
        {
            // Grabbable: Object released
            Debug.Log($"{gameObject.name} released");
        }`);
  }

  if (traits.includes('pointable') || traits.includes('hoverable')) {
    methods.push(`
        public void OnHoverEntered(HoverEnterEventArgs args)
        {
            // Hoverable: Pointer entered
        }

        public void OnHoverExited(HoverExitEventArgs args)
        {
            // Hoverable: Pointer exited
        }`);
  }

  return methods.join('\n');
}

function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, ' ')
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

// ============================================================================
// Unity Prefab Generation
// ============================================================================

/**
 * Generate Unity prefab YAML from HoloScript AST
 */
export function generatePrefab(ast: ASTNode, className: string): string {
  const guid = generateGUID();

  return `%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &${generateFileId()}
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: ${generateFileId()}}
  - component: {fileID: ${generateFileId()}}
  - component: {fileID: ${generateFileId()}}
  m_Layer: 0
  m_Name: ${ast.id || 'HoloObject'}
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
`;
}

function generateGUID(): string {
  return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/x/g, () =>
    Math.floor(Math.random() * 16).toString(16)
  );
}

function generateFileId(): number {
  return Math.floor(Math.random() * 9000000000) + 1000000000;
}

// ============================================================================
// Main Export Function
// ============================================================================

/**
 * Export HoloScript AST to Unity project files
 */
export async function exportToUnity(
  ast: ASTNode | ASTNode[],
  config: UnityExportConfig
): Promise<UnityExportResult> {
  const nodes = Array.isArray(ast) ? ast : [ast];
  const files: GeneratedFile[] = [];
  const warnings: ExportWarning[] = [];
  const errors: ExportError[] = [];

  const ns = config.namespace || `${config.projectName}.HoloScript`;

  for (const node of nodes) {
    try {
      const className = toPascalCase(node.id || 'HoloObject');

      // Generate C# script
      const csharp = generateCSharp(node, { namespace: ns });
      files.push({
        path: `${config.outputDir}/Scripts/${className}.cs`,
        content: csharp,
        type: 'script',
      });

      // Generate prefab
      const prefab = generatePrefab(node, className);
      files.push({
        path: `${config.outputDir}/Prefabs/${className}.prefab`,
        content: prefab,
        type: 'prefab',
      });

      // Check for unsupported traits
      const traits = node.traits || [];
      for (const trait of traits) {
        if (!TRAIT_TO_COMPONENT[trait]) {
          warnings.push({
            code: 'UNSUPPORTED_TRAIT',
            message: `Trait '${trait}' has no Unity mapping yet`,
            node: node.id,
          });
        }
      }
    } catch (err) {
      errors.push({
        code: 'EXPORT_ERROR',
        message: err instanceof Error ? err.message : String(err),
        node: node.id,
      });
    }
  }

  return {
    success: errors.length === 0,
    files,
    stats: {
      scriptCount: files.filter((f) => f.type === 'script').length,
      prefabCount: files.filter((f) => f.type === 'prefab').length,
      materialCount: files.filter((f) => f.type === 'material').length,
      sceneCount: files.filter((f) => f.type === 'scene').length,
      totalFiles: files.length,
    },
    warnings,
    errors,
  };
}

/**
 * Write export result to filesystem (Node.js only)
 */
export async function writeExportToFilesystem(
  result: UnityExportResult
): Promise<void> {
  const fs = await import('fs/promises');
  const path = await import('path');

  for (const file of result.files) {
    const dir = path.dirname(file.path);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(file.path, file.content, 'utf-8');
  }
}

// ============================================================================
// Package Info
// ============================================================================

export const VERSION = '1.0.0';

export const SUPPORTED_TRAITS = [
  'grabbable',
  'throwable',
  'pointable',
  'hoverable',
  'climbable',
  'physics',
  'breakable',
  'portal',
  'npc',
  'audio',
  'particle',
] as const;

export const SUPPORTED_XR_FRAMEWORKS = [
  'xr-interaction-toolkit',
  'oculus',
  'steamvr',
  'none',
] as const;

export default {
  exportToUnity,
  generateCSharp,
  generatePrefab,
  writeExportToFilesystem,
  VERSION,
  SUPPORTED_TRAITS,
  SUPPORTED_XR_FRAMEWORKS,
};
